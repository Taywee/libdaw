from collections import abc
from typing import Self
from libdaw.metronome import Beat, Metronome
from libdaw.nodes.instrument import Tone
from libdaw.pitch import A440, PitchStandard, PitchClass
from enum import Enum, auto, unique
from .duration import AddLength, SubtractLength, MultiplyLength, Constant

type _NotePitch = Step | Pitch
type _Duration = AddLength | SubtractLength | MultiplyLength | Constant


class _ChordIterator:
    def __iter__(self) -> Self: ...
    def __next__(self) -> _NotePitch: ...

class _ScaleIterator:
    def __iter__(self) -> Self: ...
    def __next__(self) -> _NotePitch: ...

class _OverlappedIterator:
    def __iter__(self) -> Self: ...
    def __next__(self) -> Item: ...

class _SequenceIterator:
    def __iter__(self) -> Self: ...
    def __next__(self) -> Item: ...

@unique
class StateMember(Enum):
    First = auto()
    Last = auto()

class Element:
    def tones(
        self,
        *,
        metronome: Metronome = Metronome(),
        pitch_standard: PitchStandard = A440(),
    ) -> abc.Sequence[Tone]: ...
    def length_(self) -> Beat: ...
    def duration_(self) -> Beat: ...

class Pitch:
    def __new__(
        cls: type,
        pitch_class: PitchClass,
        octave: int | None = None,
        octave_shift: int = 0,
    ): ...

    @property
    def pitch_class(self) -> PitchClass: ...
    @pitch_class.setter
    def pitch_class(self, value: PitchClass): ...

    @property
    def octave(self) -> int | None: ...
    @octave.setter
    def octave(self, value: int | None): ...

    @property
    def octave_shift(self) -> int: ...
    @octave_shift.setter
    def octave_shift(self, value: int): ...

class Step:
    def __new__(cls: type, step: int, octave_shift: int = 0, adjustment: float = 0.0): ...

    @property
    def step(self) -> int: ...
    @step.setter
    def step(self, value: int): ...

    @property
    def octave_shift(self) -> int: ...
    @octave_shift.setter
    def octave_shift(self, value: int): ...

    @property
    def adjustment(self) -> float: ...
    @adjustment.setter
    def adjustment(self, value: float): ...

class Item:
    def __new__(
        cls: type,
        value: Element,
    ): ...

    @property
    def element(self) -> Element: ...

    @element.setter
    def element(self, value: Element) -> None: ...

    @property
    def tags(self) -> set[str]: ...

    @staticmethod
    def loads(source: str) -> Item: ...

class Chord(Element):
    def __new__(
        cls: type,
        pitches: abc.Sequence[_NotePitch] | None = None,
        length: Beat | None = None,
        duration: _Duration | None = None,
        state_member: StateMember | None = None,
    ): ...
    @staticmethod
    def loads(source: str) -> Chord: ...

    @property
    def length(self) -> Beat | None: ...
    @length.setter
    def length(self, value: Beat | None): ...

    @property
    def duration(self) -> _Duration | None: ...
    @duration.setter
    def duration(self, value: _Duration | None): ...

    @property
    def state_member(self) -> StateMember | None: ...
    @state_member.setter
    def state_member(self, value: StateMember | None): ...


    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> _NotePitch: ...
    def __setitem__(self, index: int, value: _NotePitch): ...
    def __delitem__(self, index: int): ...
    def __iter__(self) -> _ChordIterator: ...
    def insert(self, index: int, value: _NotePitch): ...
    def pop(self, index: int | None = None) -> _NotePitch: ...
    def append(self, value: _NotePitch): ...

class Note(Element):
    def __new__(cls: type, pitch: _NotePitch, length: Beat | None = None, duration: _Duration | None = None): ...

    @staticmethod
    def loads(source: str) -> Note: ...

    @property
    def pitch(self) -> _NotePitch: ...

    @pitch.setter
    def pitch(self, value: _NotePitch): ...

    @property
    def length(self) -> Beat | None: ...
    @length.setter
    def length(self, value: Beat | None): ...
    @property
    def duration(self) -> _Duration | None: ...
    @duration.setter
    def duration(self, value: _Duration | None): ...

class Overlapped(Element):
    def __new__(
        cls: type,
        sections: abc.Sequence[Item | Element] | None = None,
        state_member: StateMember | None = None,
    ): ...
    @staticmethod
    def loads(source: str) -> Overlapped: ...

    @property
    def state_member(self) -> StateMember | None: ...
    @state_member.setter
    def state_member(self, value: StateMember | None): ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> Item: ...
    def __setitem__(self, index: int, value: Item | Element | abc.Sequence[Item | Element]): ...
    def __delitem__(self, index: int): ...
    def __iter__(self) -> _OverlappedIterator: ...
    def insert(self, index: int, value: Item | Element): ...
    def pop(self, index: int | None = None) -> Item: ...
    def append(self, value: Item | Element): ...

class Rest(Element):
    def __new__(cls: type, length: Beat | None = None): ...

    @staticmethod
    def loads(source: str) -> Rest: ...

    @property
    def length(self) -> Beat | None: ...
    @length.setter
    def length(self, value: Beat | None): ...

class Sequence(Element):
    def __new__(
        cls: type,
        items: abc.Sequence[Item | Element] | None = None,
        state_member: StateMember | None = None,
    ): ...

    @staticmethod
    def loads(source: str) -> Sequence: ...

    @property
    def state_member(self) -> StateMember | None: ...
    @state_member.setter
    def state_member(self, value: StateMember | None): ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> Item: ...
    def __setitem__(self, index: int, value: Item | Element | abc.Sequence[Item | Element]): ...
    def __delitem__(self, index: int): ...
    def __iter__(self) -> _SequenceIterator: ...
    def insert(self, index: int, value: Item | Element): ...
    def pop(self, index: int | None = None) -> Item: ...
    def append(self, value: Item | Element): ...

class Scale(Element):
    def __new__(cls: type, pitches: abc.Sequence[_NotePitch]): ...

    @staticmethod
    def loads(source: str) -> Scale: ...

    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> _NotePitch: ...
    def __setitem__(self, index: int, value: _NotePitch): ...
    def __delitem__(self, index: int): ...
    def __iter__(self) -> _ScaleIterator: ...
    def insert(self, index: int, value: _NotePitch): ...
    def pop(self, index: int | None = None) -> _NotePitch: ...
    def append(self, value: _NotePitch): ...

class Mode(Element):
    def __new__(cls: type, mode: int): ...

    @staticmethod
    def loads(source: str) -> Mode: ...

    @property
    def mode(self) -> int: ...
    @mode.setter
    def mode(self, value: int): ...

class Set(Element):
    def __new__(
        cls: type,
        pitch: _NotePitch | None = None,
        length: Beat | None = None,
        duration: _Duration | None = None,
    ): ...
    @staticmethod
    def loads(source: str) -> Set: ...

    @property
    def pitch(self) -> _NotePitch | None: ...
    @pitch.setter
    def pitch(self, value: _NotePitch | None): ...

    @property
    def length(self) -> Beat | None: ...
    @length.setter
    def length(self, value: Beat | None): ...

    @property
    def duration(self) -> _Duration | None: ...
    @duration.setter
    def duration(self, value: _Duration | None): ...

